---
layout: post
title: Cyclical iterators in Python
tags: [cyclical iterator, python, iterator, generator, factorial]
---

<p>
I recently came across an amazing technique for manipulating Python iterators in a <a href="http://code.activestate.com/recipes/576961-technique-for-cyclical-iteration/" title="Technique for cyclical iteration">recipe</a> by Raymond Hettinger.
</p>

<p>
The technique consists in defining an iterator as a function of itself, thus making a cyclical definition. The recipe hinges on using itertools.tee to split the to-be iterator, which is forward-referenced in a function before it is built, and feeding one (or more) of the tee'd iterators into the other.
</p>

<table class="img-wrap standout">
    <tr><td><img src="/img/ouroboros.jpg" title="Ouroboros" /></td></tr>
    <tr><td class="img-caption">-- The Ouroboros comes to mind</td><tr>
</table>

<p>
Bear with me, I'll explain in a moment.
</p>

<p>
Cyclical iterators can be quite useful when defining infinite iterators for recursive sequences. The problem solved by the recipe (generating <a href="http://en.wikipedia.org/wiki/Regular_number" title="Regular Numbers on Wikipedia">5-smooth numbers</a>) has this very recursive notion, in the sense that, given a set of these numbers, mutiplying each by 2, 3 and 5 yields a larger set of such numbers.
</p>

<p>
Or, to explore the inductive side of the problem, given an iterator for the first n 5-smooth numbers, you can define a larger iterator for 5-smooth numbers by exhausting the first one and multiplying each number it outputs by 2, 3 and 5 (and eliminating duplicates).
</p>

<p>
And that is exactly what the recipe does: starting with a seed value of 1 (the first 5-smooth number), it builds an iterator that swallows itself, multiplying each already-generated number by 2, 3 and 5, sorting increasingly and eliminating duplicates.
</p>

<p>
I came up with this different (simpler) example while getting my head around the technique, which I'll explain in greater detail:
</p>

{% highlight python %}
{% include snippets/factorial.py %}
{% endhighlight %}

<p>
This returns a factorial iterator, which outputs sequentially 1!, 2!, 3! and so on. The inductive nature of the problem presents itself more clearly this time: given an iterator for the first n factorials, we can exhaust it and multiply the last value it generated by n+1 to obtain an iterator for the first n+1 factorials.
</p>

<p>
Let's walk by it one line at a time.
</p>

<p>
Lines 01 to 03 aren't of much interest. They only make a few imports we'll need and define the function <em>factorials()</em>, which returns the factorial iterator.
</p>

<p>
Things start to get interesting in lines 04 to 07 as we define a generator inside <em>factorials()</em> which simply iterates through some <em>output</em> variable and yields every item in it. This is a delayed reference to <em>output</em>: we don't want to evaluate it right now because it points to nowhere (that is, it's not defined), but we want to use it anyway. Hence, we wrap <em>output</em> in a generator, so that it only gets evaluated when the generator is being traversed.
</p>

<p>
Then on line 9 we split the iterator returned by <em>delayed_output()</em> in two: one <em>result</em>, which we will return from <em>factorials()</em>, and a <em>feedback</em> iterator, which we will feed into itself.
</p>

<p>
This is the picture we have so far:
</p>

<table class="img-wrap standout">
    <tr><td><img src="/img/line9.png" title="Diagram for line 9" /></td></tr>
    <tr><td class="img-caption">-- Diagram for line 9</td><tr>
</table>

<p>
Note that <em>output</em> still points to nowhere, and if we get it to point to <em>feedback</em> somehow, then we will be making <em>feedback</em> indirectly point to itself.
</p>

<p>
Also note that I represented <em>output</em> twice. This emphasizes that, once we tee'd the delayed reference to it, we can have <em>result</em> and <em>feedback</em> pointing to different parts of the iteration. More on that later.
</p>

<p>
In line 10 we seed the cyclical iterator with the first value, 1!, which is just 1. We do that by defining another iterator, <em>seeded</em>, which will first yield the seed value, then proceed with the values it finds in <em>feedback</em>. Here's the diagram:
</p>

<table class="img-wrap standout">
    <tr><td><img src="/img/line10.png" title="Diagram for line 10" /></td></tr>
    <tr><td class="img-caption">-- Diagram for line 10</td><tr>
</table>

<p>
And finally, on line 11, we define yet another iterator, which grabs one value from <em>seeded</em>, our inductive factorial generator, and one value from the infinite sequence 1,2,3,4..., multiplies them and yields the result. This is where the iterator for n factorials becomes an iterator for n+1 factorials.
</p>

<p>
But wait, what is that iterator called? <em>output</em>! The Python bites its own tail as we close the cycle and make <em>feedback</em> point to itself indirectly. Check out the diagram:
</p>

<table class="img-wrap standout">
    <tr><td><img src="/img/line11.png" title="Diagram for line 11" /></td></tr>
    <tr><td class="img-caption">-- Diagram for line 11</td><tr>
</table>

<p>
And then we return <em>result</em>, which remained unchanged since line 09. It helps to think that <em>result</em> always points to one value before <em>seeded</em>. That is, every time a new factorial is requested from <em>result</em>, <em>seeded</em> moves one position ahead, on to the next factorial.
</p>
